// Generated by CoffeeScript 1.7.1
var allCapturedSeries, annotator, classAlreadyRegistered, counter, findSeries, graph, hoverDetail, palette, previewXAxis, receiveObjectData, ticksTreatment, xAxis, yAxis;

palette = new Rickshaw.Color.Palette({
  scheme: 'classic9'
});

this.SeriesData = (function() {
  function SeriesData(objCount, className, color, counter) {
    this.data = objCount;
    this.className = className;
    this.color = color || palette.color();
    this.counter = counter;
  }

  SeriesData.prototype.toHash = function() {
    var data;
    data = new Object();
    data.x = this.counter;
    data.y = this.data;
    return {
      color: this.color,
      data: [data],
      name: this.className
    };
  };

  return SeriesData;

})();

allCapturedSeries = [
  {
    color: palette.color(),
    data: [
      {
        x: 0,
        y: 0
      }
    ],
    name: 'none'
  }
];

graph = new Rickshaw.Graph({
  element: document.getElementById("chart"),
  width: '750',
  height: 450,
  renderer: 'bar',
  stroke: true,
  preserve: true,
  series: allCapturedSeries
});

graph.render();

hoverDetail = new Rickshaw.Graph.HoverDetail({
  graph: graph,
  xFormatter: function(x) {
    return new Date(x * 1000).toString();
  }
});

annotator = new Rickshaw.Graph.Annotate({
  graph: graph,
  element: document.getElementById('timeline')
});

ticksTreatment = 'glow';

xAxis = new Rickshaw.Graph.Axis.Time({
  graph: graph,
  ticksTreatment: ticksTreatment,
  timeFixture: new Rickshaw.Fixtures.Time.Local()
});

xAxis.render();

yAxis = new Rickshaw.Graph.Axis.Y({
  graph: graph,
  tickFormat: Rickshaw.Fixtures.Number.formatKMBT,
  ticksTreatment: ticksTreatment
});

yAxis.render();

previewXAxis = new Rickshaw.Graph.Axis.Time({
  graph: graph,
  timeFixture: new Rickshaw.Fixtures.Time.Local(),
  ticksTreatment: ticksTreatment
});

previewXAxis.render();

counter = 0;

receiveObjectData = function(objectData) {
  var className, count, dataToPush, seriesData, seriesToPushTo;
  for (className in objectData) {
    count = objectData[className];
    if (classAlreadyRegistered(className)) {
      seriesToPushTo = findSeries(className);
      dataToPush = {
        x: counter,
        y: count
      };
      seriesToPushTo.data.push(dataToPush);
    } else {
      seriesData = new this.SeriesData(count, className, counter);
      allCapturedSeries.push(seriesData.toHash());
      data.push(seriesData.toHash());
    }
  }
  counter += 1;
  return graph.update();
};

classAlreadyRegistered = function(className) {
  var filteredClasses;
  filteredClasses = allCapturedSeries.filter(function(element, index) {
    return element.className === className;
  });
  return filteredClasses.length > 0;
};

findSeries = function(className) {
  var filteredClasses;
  filteredClasses = allCapturedSeries.filter(function(element, index) {
    return element.className === className;
  });
  return filteredClasses[0];
};

this.tryQtBridge = function() {
  if (window.rbkitClient) {
    return window.rbkitClient.sendDatatoJs.connect(receiveObjectData);
  }
};

setInterval(tryQtBridge, 1000);
