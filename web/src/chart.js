// Generated by CoffeeScript 1.7.1
var chart,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

this.Chart = (function() {
  var dataForNewSeries, placeHolderSeries;

  placeHolderSeries = function() {
    var num, _i, _results;
    _results = [];
    for (num = _i = -9; _i <= 0; num = ++_i) {
      _results.push([(new Date()).getTime() + num * 1000, 0]);
    }
    return _results;
  };

  dataForNewSeries = function(series, currentTime, count) {
    var data, newData, num;
    data = series.data;
    newData = (function() {
      var _i, _results;
      _results = [];
      for (num = _i = 0; _i <= 8; num = ++_i) {
        _results.push([data[num].x, 0]);
      }
      return _results;
    })();
    newData.push([currentTime, count]);
    return newData;
  };

  function Chart() {
    this.updateChart = __bind(this.updateChart, this);
    this.receiveLiveData = __bind(this.receiveLiveData, this);
    this.establishQtBridge = __bind(this.establishQtBridge, this);
    this.tryQtBridge = __bind(this.tryQtBridge, this);
    this.knownClasses = {
      "String": true
    };
    this.legendIndex = 1;
    this.currentObjectCount = {
      "String": 0
    };
    this.objectsAsOther = {};
  }

  Chart.prototype.plotChart = function() {
    return this.chart = $("#container").highcharts({
      chart: {
        type: 'column'
      },
      title: {
        text: 'Live objects'
      },
      xAxis: {
        type: 'datetime',
        tickPixelInterval: 150,
        title: {
          enabled: false
        }
      },
      yAxis: {
        min: 0,
        title: {
          text: 'Live Objects'
        },
        stackLabels: {
          enabled: true,
          style: {
            fontWeight: 'bold',
            color: (Highcharts.theme && Highcharts.theme.textColor) || 'gray'
          }
        }
      },
      plotOptions: {
        column: {
          stacking: 'normal',
          dataLabels: {
            enabled: false,
            color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white',
            style: {
              textShadow: '0 0 3px black, 0 0 3px black'
            }
          }
        }
      },
      series: [
        {
          name: 'String',
          data: placeHolderSeries()
        }
      ]
    }).highcharts();
  };

  Chart.prototype.tryQtBridge = function() {
    return window.setTimeout(this.establishQtBridge, 1000);
  };

  Chart.prototype.establishQtBridge = function() {
    setInterval(this.updateChart, 1000);
    if (window.rbkitClient) {
      return window.rbkitClient.sendDatatoJs.connect(this.receiveLiveData);
    }
  };

  Chart.prototype.receiveLiveData = function(liveObjectCount) {
    return this.addToCurrentObjects(liveObjectCount);
  };

  Chart.prototype.addToOther = function(objectType, count) {
    return this.objectsAsOther[objectType] = count;
  };

  Chart.prototype.addToCurrentObjects = function(liveObjectCount) {
    var count, knownClassesCount, objectType, _results;
    _results = [];
    for (objectType in liveObjectCount) {
      count = liveObjectCount[objectType];
      knownClassesCount = Object.keys(this.currentObjectCount).length;
      if (this.currentObjectCount[objectType] != null) {
        _results.push(this.currentObjectCount[objectType] = count);
      } else {
        if ((this.objectsAsOther[objectType] != null)) {
          _results.push(this.addToOther(objectType, count));
        } else {
          if (knownClassesCount < 8) {
            _results.push(this.currentObjectCount[objectType] = count);
          } else {
            _results.push(this.addToOther(objectType, count));
          }
        }
      }
    }
    return _results;
  };

  Chart.prototype.updateChart = function() {
    var count, currentTime, objectType, otherCount, _ref, _ref1;
    currentTime = (new Date()).getTime();
    _ref = this.currentObjectCount;
    for (objectType in _ref) {
      count = _ref[objectType];
      if (this.knownClasses[objectType] != null) {
        this.addNewDataPoint(objectType, count, currentTime);
      } else {
        this.addNewSeries(objectType, count, currentTime);
      }
    }
    otherCount = 0;
    _ref1 = this.objectsAsOther;
    for (objectType in _ref1) {
      count = _ref1[objectType];
      otherCount += count;
    }
    if (otherCount > 0) {
      if (this.knownClasses["Other"] != null) {
        return this.addNewDataPoint("Other", otherCount, currentTime);
      } else {
        return this.addNewSeries("Other", otherCount, currentTime);
      }
    }
  };

  Chart.prototype.addNewDataPoint = function(objectType, count, currentTime) {
    var selectedSeries, series;
    selectedSeries = ((function() {
      var _i, _len, _ref, _results;
      _ref = this.chart.series;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        series = _ref[_i];
        if (series.name === objectType) {
          _results.push(series);
        }
      }
      return _results;
    }).call(this))[0];
    return selectedSeries.addPoint([currentTime, count], true, true);
  };

  Chart.prototype.addNewSeries = function(objectType, count, currentTime) {
    this.chart.addSeries({
      name: objectType,
      data: dataForNewSeries(this.chart.series[0], currentTime, count),
      legendIndex: this.legendIndex
    }, true, true);
    this.knownClasses[objectType] = true;
    return this.legendIndex += 1;
  };

  return Chart;

})();

chart = new Chart();

chart.plotChart();

chart.tryQtBridge();
